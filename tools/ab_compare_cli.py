#!/usr/bin/env python3
from __future__ import annotations

import argparse
import csv
import json
import os
import random
from pathlib import Path
from typing import Dict, List, Optional


FIELDS = [
    "Contract Name",
    "Contract Type",
    "SOW Value in EUR",
    "PWO#",
    "Managed By",
]


def _load_csv_rows(path: str) -> List[Dict[str, str]]:
    with open(path, 'r', encoding='utf-8-sig', newline='') as f:
        return list(csv.DictReader(f))


def _save_pref(record: dict, out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, 'a', encoding='utf-8') as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


def run_from_csv(pred_a: str, pred_b: str, sample: int, out: str) -> None:
    a_rows = _load_csv_rows(pred_a)
    b_rows = _load_csv_rows(pred_b)
    # index by Source File when available, else by position
    def _index(rows):
        idx = {}
        for i, r in enumerate(rows):
            key = r.get('Source File') or str(i)
            idx[key] = r
        return idx
    A = _index(a_rows)
    B = _index(b_rows)
    keys = [k for k in A.keys() if k in B]
    if sample and sample < len(keys):
        random.Random(42).shuffle(keys)
        keys = keys[:sample]

    out_path = Path(out)
    for k in keys:
        ra, rb = A[k], B[k]
        print(f"\n=== {k} ===")
        for fld in FIELDS:
            va = (ra.get(fld, '') or '').strip()
            vb = (rb.get(fld, '') or '').strip()
            if not (va or vb):
                continue
            print(f"\nField: {fld}")
            print(f"A: {va}")
            print(f"B: {vb}")
            choice = input("Choose [A/B/T=Tie/S=Skip]: ").strip().lower()
            if choice not in ('a','b','t','s'):
                choice = 's'
            rec = {
                'source_file': k,
                'field': fld,
                'a': va,
                'b': vb,
                'choice': {'a':'A','b':'B','t':'TIE','s':'SKIP'}[choice]
            }
            _save_pref(rec, out_path)
    print(f"\n✅ Preferences saved to: {out_path}")


def export_pairs(preferences_jsonl: str, out_pairs: str) -> None:
    rnd = random.Random(42)
    outp = Path(out_pairs)
    outp.parent.mkdir(parents=True, exist_ok=True)
    with open(preferences_jsonl, 'r', encoding='utf-8') as f_in, open(outp, 'w', encoding='utf-8') as f_out:
        for line in f_in:
            try:
                obj = json.loads(line)
            except Exception:
                continue
            choice = obj.get('choice')
            a, b = obj.get('a', ''), obj.get('b', '')
            if not a or not b:
                continue
            if choice == 'A':
                f_out.write(json.dumps({'text1': a, 'text2': b, 'label': 1.0, 'field': obj.get('field')}, ensure_ascii=False) + "\n")
            elif choice == 'B':
                f_out.write(json.dumps({'text1': b, 'text2': a, 'label': 1.0, 'field': obj.get('field')}, ensure_ascii=False) + "\n")
            elif choice == 'TIE':
                # weak positive both ways
                f_out.write(json.dumps({'text1': a, 'text2': b, 'label': 0.7, 'field': obj.get('field')}, ensure_ascii=False) + "\n")
            else:
                # skip
                pass
    print(f"✅ Exported ST pairs to: {outp}")


def main() -> None:
    p = argparse.ArgumentParser(description='A/B side-by-side model comparison')
    p.add_argument('--model-a', help='Path to model A (unused when comparing CSVs)')
    p.add_argument('--model-b', help='Path to model B (unused when comparing CSVs)')
    p.add_argument('--pdf-dir', help='PDF directory (for future live extraction mode)')
    p.add_argument('--pred-a', help='Predictions CSV from model A')
    p.add_argument('--pred-b', help='Predictions CSV from model B')
    p.add_argument('--sample', type=int, default=10)
    p.add_argument('--out', default='datasets/preferences.jsonl')
    p.add_argument('--export-pairs', action='store_true', help='Only export pairs from an existing preferences file (use --out as input)')
    p.add_argument('--pairs-out', default='datasets/st_pairs_pref.jsonl')
    args = p.parse_args()

    if args.export_pairs:
        export_pairs(args.out, args.pairs_out)
        return

    if args.pred_a and args.pred_b:
        run_from_csv(args.pred_a, args.pred_b, args.sample, args.out)
        return

    print("Live extraction A/B is not enabled in this version to avoid heavy runtime deps.\n"
          "Please provide --pred-a and --pred-b CSVs generated by running the extractor\n"
          "with each model.")


if __name__ == '__main__':
    main()

